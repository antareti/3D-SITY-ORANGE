<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Neon Overdrive - Infinite City</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        #ui {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border: 2px solid #00ffff;
            text-align: center;
            cursor: pointer;
            z-index: 100;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
            letter-spacing: 2px;
        }
        #ui b { font-size: 28px; display: block; margin-bottom: 10px; color: #ff00ff; }
        #speedometer {
            position: absolute;
            bottom: 20px; right: 20px;
            color: #00ffff; font-size: 24px;
            text-shadow: 0 0 10px #00ffff;
        }
    </style>
</head>
<body>

    <div id="ui">
        <b>NEON OVERDRIVE</b>
        W, A, S, D — УПРАВЛЕНИЕ<br>
        MOUSE — ОБЗОР<br><br>
        [ КЛИК ДЛЯ ВХОДА В СИСТЕМУ ]
    </div>

    <div id="speedometer">SPD: 0 KM/H</div>

    <audio id="bgMusic" loop>
        <source src="run.mp3" type="audio/mpeg">
    </audio>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>

    <script>
        // --- КОНФИГУРАЦИЯ ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.012);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.body.appendChild(renderer.domElement);

        // --- ТЕКСТУРЫ ---
        const textureLoader = new THREE.TextureLoader();
        const buildingTexture = textureLoader.load('1.png');
        buildingTexture.wrapS = buildingTexture.wrapT = THREE.RepeatWrapping;

        // --- ПОСТОБРАБОТКА (BLOOM) ---
        const renderScene = new THREE.RenderPass(scene, camera);
        const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.2;
        bloomPass.strength = 1.2; 
        bloomPass.radius = 0.1;

        const composer = new THREE.EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- ОСВЕЩЕНИЕ ---
        const ambient = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambient);

        // --- МАШИНА (КАПОТ И ФАРЫ) ---
        const hoodGroup = new THREE.Group();
        
        const hoodGeo = new THREE.BoxGeometry(3.5, 0.1, 4);
        const hoodMat = new THREE.MeshStandardMaterial({ 
            color: 0x001133, 
            metalness: 1, 
            roughness: 0.1,
            emissive: 0x0022ff,
            emissiveIntensity: 0.2
        });
        const hood = new THREE.Mesh(hoodGeo, hoodMat);
        hoodGroup.add(hood);

        const lightBoxGeo = new THREE.BoxGeometry(0.8, 0.2, 0.2);
        const lightBoxMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        
        const leftLight = new THREE.Mesh(lightBoxGeo, lightBoxMat);
        leftLight.position.set(-1.2, 0.1, -2);
        hoodGroup.add(leftLight);

        const rightLight = new THREE.Mesh(lightBoxGeo, lightBoxMat);
        rightLight.position.set(1.2, 0.1, -2);
        hoodGroup.add(rightLight);

        const createHeadlight = (x) => {
            const spotLight = new THREE.SpotLight(0xffffff, 10, 40, Math.PI/6, 0.5, 1);
            spotLight.position.set(x, 0.1, -2);
            spotLight.target.position.set(x, -0.5, -15);
            hoodGroup.add(spotLight);
            hoodGroup.add(spotLight.target);
            return spotLight;
        };
        createHeadlight(-1.2);
        createHeadlight(1.2);

        hoodGroup.position.set(0, -0.8, -1.5);
        camera.add(hoodGroup);
        scene.add(camera);

        // --- ЗВЕЗДНОЕ НЕБО ---
        const starGeo = new THREE.BufferGeometry();
        const starCoords = [];
        for (let i = 0; i < 3000; i++) {
            starCoords.push((Math.random() - 0.5) * 1000, Math.random() * 500, (Math.random() - 0.5) * 1000);
        }
        starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starCoords, 3));
        const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.8, transparent: true });
        const stars = new THREE.Points(starGeo, starMat);
        scene.add(stars);

        // --- ГЕНЕРАЦИЯ ГОРОДА ---
        const buildings = [];
        const gridSize = 500;
        const boxGeo = new THREE.BoxGeometry(1, 1, 1);
        
        for (let i = 0; i < 600; i++) {
            const h = Math.random() * 40 + 5;
            const w = Math.random() * 5 + 3;
            
            const material = new THREE.MeshStandardMaterial({
                map: buildingTexture,
                color: 0xffffff,
                emissive: Math.random() > 0.5 ? 0x00ffff : 0xff00ff,
                emissiveIntensity: Math.random() * 0.4
            });

            const building = new THREE.Mesh(boxGeo, material);
            building.scale.set(w, h, w);
            building.position.set((Math.random() - 0.5) * gridSize, h / 2, (Math.random() - 0.5) * gridSize);
            scene.add(building);
            buildings.push(building);
        }

        const grid = new THREE.GridHelper(gridSize * 2, 80, 0x00ffff, 0x330033);
        scene.add(grid);

        // --- ТРАФИК ---
        const trafficLights = [];
        for(let i=0; i<40; i++) {
            const lightGeo = new THREE.BoxGeometry(0.2, 0.2, 5);
            const lightMat = new THREE.MeshBasicMaterial({ color: Math.random() > 0.5 ? 0x00ffff : 0xff00ff });
            const light = new THREE.Mesh(lightGeo, lightMat);
            light.position.set((Math.random()-0.5)*100, 1, (Math.random()-0.5)*gridSize);
            scene.add(light);
            trafficLights.push(light);
        }

        // --- ПЕРЕМЕННЫЕ СОСТОЯНИЯ ---
        let moveFwd = false, moveBwd = false, moveL = false, moveR = false;
        let yaw = 0, pitch = 0;
        let velocity = new THREE.Vector3();
        let acceleration = 0.02;
        let friction = 0.96;
        let currentSpeed = 0;

        const ui = document.getElementById('ui');
        const spdElem = document.getElementById('speedometer');
        const music = document.getElementById('bgMusic');

        // --- УПРАВЛЕНИЕ ---
        ui.addEventListener('click', () => {
            document.body.requestPointerLock();
            music.volume = 0.4;
            music.play().catch(() => {});
        });

        document.addEventListener('pointerlockchange', () => {
            ui.style.display = document.pointerLockElement ? 'none' : 'block';
        });

        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement) {
                yaw -= e.movementX * 0.002;
                pitch -= e.movementY * 0.002;
                pitch = Math.max(-Math.PI/4, Math.min(Math.PI/4, pitch));
            }
        });

        const onKey = (val) => (e) => {
            if (e.code === 'KeyW') moveFwd = val;
            if (e.code === 'KeyS') moveBwd = val;
            if (e.code === 'KeyA') moveL = val;
            if (e.code === 'KeyD') moveR = val;
        };
        document.addEventListener('keydown', onKey(true));
        document.addEventListener('keyup', onKey(false));

        // --- ГЛАВНЫЙ ЦИКЛ ---
        camera.position.set(0, 2, 0);

        function animate() {
            requestAnimationFrame(animate);

            if (document.pointerLockElement) {
                camera.rotation.set(pitch, yaw, 0, 'YXZ');

                const dir = new THREE.Vector3();
                if (moveFwd) dir.z -= 1;
                if (moveBwd) dir.z += 1;
                if (moveL) dir.x -= 1;
                if (moveR) dir.x += 1;

                dir.normalize().applyQuaternion(camera.quaternion);
                dir.y = 0;

                if (dir.length() > 0) {
                    velocity.addScaledVector(dir, acceleration);
                }
                
                velocity.multiplyScalar(friction);
                camera.position.add(velocity);
                camera.position.y = 2;

                let targetTilt = 0;
                if (moveL) targetTilt = 0.08;
                if (moveR) targetTilt = -0.08;
                camera.rotation.z = THREE.MathUtils.lerp(camera.rotation.z, targetTilt, 0.1);

                currentSpeed = Math.round(velocity.length() * 500);
                spdElem.innerText = `SPD: ${currentSpeed} KM/H`;

                buildings.forEach(b => {
                    if (b.position.x - camera.position.x > gridSize / 2) b.position.x -= gridSize;
                    if (b.position.x - camera.position.x < -gridSize / 2) b.position.x += gridSize;
                    if (b.position.z - camera.position.z > gridSize / 2) b.position.z -= gridSize;
                    if (b.position.z - camera.position.z < -gridSize / 2) b.position.z += gridSize;
                });

                trafficLights.forEach(l => {
                    l.position.z += 2;
                    if (l.position.z - camera.position.z > gridSize / 2) l.position.z -= gridSize;
                });

                grid.position.x = Math.floor(camera.position.x / 10) * 10;
                grid.position.z = Math.floor(camera.position.z / 10) * 10;
                stars.position.copy(camera.position);
            }
            
            composer.render();
        }
        
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
