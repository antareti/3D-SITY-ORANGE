<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Neon Overdrive - Mercedes Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        #ui {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border: 2px solid #00ffff;
            text-align: center;
            cursor: pointer;
            z-index: 100;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
            letter-spacing: 2px;
        }
        #ui b { font-size: 28px; display: block; margin-bottom: 10px; color: #ff00ff; }
        #speedometer {
            position: absolute;
            bottom: 20px; right: 20px;
            color: #00ffff; font-size: 24px;
            text-shadow: 0 0 10px #00ffff;
        }
    </style>
</head>
<body>

    <div id="ui">
        <b>NEON OVERDRIVE: GT</b>
        W, A, S, D — УПРАВЛЕНИЕ<br>
        MOUSE — ОБЗОР<br><br>
        [ КЛИК ДЛЯ ВХОДА В СИСТЕМУ ]
    </div>

    <div id="speedometer">SPD: 0 KM/H</div>

    <audio id="bgMusic" loop>
        <source src="run.mp3" type="audio/mpeg">
    </audio>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>

    <script>
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.012);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.body.appendChild(renderer.domElement);

        const textureLoader = new THREE.TextureLoader();
        const bTex = textureLoader.load('1.png', (tex) => {
            tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(1, 2);
        });
        const hoodTexture = textureLoader.load('a.png');

        const renderScene = new THREE.RenderPass(scene, camera);
        const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        const composer = new THREE.EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        scene.add(new THREE.AmbientLight(0xffffff, 0.4));

        // --- МАШИНА С ПЕРЕДКОМ MERCEDES ---
        const hoodGroup = new THREE.Group();
        
        // Основной корпус капота
        const hoodMat = [
            new THREE.MeshStandardMaterial({ color: 0x050505 }), 
            new THREE.MeshStandardMaterial({ color: 0x050505 }), 
            new THREE.MeshStandardMaterial({ map: hoodTexture, emissive: 0xffffff, emissiveIntensity: 0.2 }), // Капот a.png
            new THREE.MeshStandardMaterial({ color: 0x050505 }), 
            new THREE.MeshStandardMaterial({ color: 0x050505 }), 
            new THREE.MeshStandardMaterial({ color: 0x050505 })  
        ];
        const hood = new THREE.Mesh(new THREE.BoxGeometry(3.5, 0.2, 4), hoodMat);
        hoodGroup.add(hood);

        // Решетка радиатора (Panamericana style)
        const grilleGeo = new THREE.BoxGeometry(1.8, 0.6, 0.1);
        const grilleMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
        const grille = new THREE.Mesh(grilleGeo, grilleMat);
        grille.position.set(0, -0.3, -2.05);
        hoodGroup.add(grille);

        // Вертикальные полоски решетки
        for(let i = -8; i <= 8; i++) {
            const bar = new THREE.Mesh(
                new THREE.BoxGeometry(0.03, 0.55, 0.05),
                new THREE.MeshBasicMaterial({ color: 0x00ffff })
            );
            bar.position.set(i * 0.1, -0.3, -2.1);
            hoodGroup.add(bar);
        }

        // Фары (L-shape Mercedes)
        const createHeadlight = (side) => {
            const headlight = new THREE.Group();
            const part1 = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.15, 0.1), new THREE.MeshBasicMaterial({ color: 0xffffff }));
            const part2 = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.4, 0.1), new THREE.MeshBasicMaterial({ color: 0xffffff }));
            part2.position.set(side * 0.35, -0.15, 0);
            headlight.add(part1, part2);
            headlight.position.set(side * 1.3, -0.1, -2.05);
            return headlight;
        };
        hoodGroup.add(createHeadlight(1));
        hoodGroup.add(createHeadlight(-1));

        // Свет фар
        const createSpot = (x) => {
            const s = new THREE.SpotLight(0xffffff, 15, 60, Math.PI/5, 0.3, 1);
            s.position.set(x, -0.1, -2.1);
            s.target.position.set(x, -1, -20);
            hoodGroup.add(s); hoodGroup.add(s.target);
        };
        createSpot(-1.3); createSpot(1.3);

        hoodGroup.position.set(0, -0.7, -1.2);
        camera.add(hoodGroup);
        scene.add(camera);

        // --- ОКРУЖЕНИЕ ---
        const starCoords = [];
        for (let i = 0; i < 3000; i++) starCoords.push((Math.random()-0.5)*1000, Math.random()*500, (Math.random()-0.5)*1000);
        const starGeo = new THREE.BufferGeometry();
        starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starCoords, 3));
        scene.add(new THREE.Points(starGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.7 })));

        const buildings = [];
        const gridSize = 500;
        for (let i = 0; i < 600; i++) {
            const h = Math.random() * 40 + 5;
            const w = Math.random() * 5 + 3;
            const building = new THREE.Mesh(
                new THREE.BoxGeometry(1, 1, 1),
                new THREE.MeshStandardMaterial({ map: bTex, emissive: Math.random() > 0.5 ? 0x00ffff : 0xff00ff, emissiveIntensity: 0.3 })
            );
            building.scale.set(w, h, w);
            building.position.set((Math.random()-0.5)*gridSize, h/2, (Math.random()-0.5)*gridSize);
            scene.add(building);
            buildings.push(building);
        }

        const grid = new THREE.GridHelper(gridSize * 2, 80, 0x00ffff, 0x330033);
        scene.add(grid);

        const tLights = [];
        for(let i=0; i<40; i++) {
            const l = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.2,5), new THREE.MeshBasicMaterial({color: Math.random()>0.5?0x00ffff:0xff00ff}));
            l.position.set((Math.random()-0.5)*100, 1, (Math.random()-0.5)*gridSize);
            scene.add(l); tLights.push(l);
        }

        // --- ЛОГИКА ---
        let moveFwd = false, moveBwd = false, moveL = false, moveR = false;
        let yaw = 0, pitch = 0, velocity = new THREE.Vector3();
        const ui = document.getElementById('ui'), spdElem = document.getElementById('speedometer'), music = document.getElementById('bgMusic');

        ui.addEventListener('click', () => { document.body.requestPointerLock(); music.play().catch(()=>{}); });
        document.addEventListener('pointerlockchange', () => ui.style.display = document.pointerLockElement ? 'none' : 'block');
        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement) {
                yaw -= e.movementX * 0.002; pitch -= e.movementY * 0.002;
                pitch = Math.max(-Math.PI/4, Math.min(Math.PI/4, pitch));
            }
        });

        const onKey = (v) => (e) => {
            if (e.code==='KeyW') moveFwd=v; if (e.code==='KeyS') moveBwd=v;
            if (e.code==='KeyA') moveL=v; if (e.code==='KeyD') moveR=v;
        };
        document.addEventListener('keydown', onKey(true)); document.addEventListener('keyup', onKey(false));

        function animate() {
            requestAnimationFrame(animate);
            if (document.pointerLockElement) {
                camera.rotation.set(pitch, yaw, 0, 'YXZ');
                const dir = new THREE.Vector3();
                if (moveFwd) dir.z -= 1; if (moveBwd) dir.z += 1;
                if (moveL) dir.x -= 1; if (moveR) dir.x += 1;
                dir.normalize().applyQuaternion(camera.quaternion); dir.y = 0;

                if (dir.length() > 0) velocity.addScaledVector(dir, 0.03);
                velocity.multiplyScalar(0.96);
                camera.position.add(velocity); camera.position.y = 2;

                camera.rotation.z = THREE.MathUtils.lerp(camera.rotation.z, moveL ? 0.05 : (moveR ? -0.05 : 0), 0.1);
                spdElem.innerText = `SPD: ${Math.round(velocity.length()*500)} KM/H`;

                buildings.forEach(b => {
                    if (b.position.x - camera.position.x > 250) b.position.x -= 500;
                    if (b.position.x - camera.position.x < -250) b.position.x += 500;
                    if (b.position.z - camera.position.z > 250) b.position.z -= 500;
                    if (b.position.z - camera.position.z < -250) b.position.z += 500;
                });
                tLights.forEach(l => {
                    l.position.z += 2.5; if (l.position.z - camera.position.z > 250) l.position.z -= 500;
                });
                grid.position.set(Math.floor(camera.position.x/10)*10, 0, Math.floor(camera.position.z/10)*10);
            }
            composer.render();
        }
        animate();
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
