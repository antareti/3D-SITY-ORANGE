<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Neon Overdrive - Infinite City</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        #ui {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border: 2px solid #00ffff;
            text-align: center;
            cursor: pointer;
            z-index: 100;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
            letter-spacing: 2px;
        }
        #ui b { font-size: 28px; display: block; margin-bottom: 10px; color: #ff00ff; }
        #speedometer {
            position: absolute;
            bottom: 20px; right: 20px;
            color: #00ffff; font-size: 24px;
            text-shadow: 0 0 10px #00ffff;
        }
    </style>
</head>
<body>

    <div id="ui">
        <b>NEON OVERDRIVE</b>
        W, A, S, D — УПРАВЛЕНИЕ<br>
        MOUSE — ОБЗОР<br><br>
        [ КЛИК ДЛЯ ВХОДА В СИСТЕМУ ]
    </div>

    <div id="speedometer">SPD: 0 KM/H</div>

    <audio id="bgMusic" loop>
        <source src="run.mp3" type="audio/mpeg">
    </audio>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>

    <script>
        // --- КОНФИГУРАЦИЯ ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.012);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.body.appendChild(renderer.domElement);

        // --- ЗАГРУЗКА ТЕКСТУР ---
        const textureLoader = new THREE.TextureLoader();
        
        // Текстура зданий
        const bTex = textureLoader.load('1.png', (tex) => {
            tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(1, 2);
        });

        // Текстура капота (a.png)
        const hoodTexture = textureLoader.load('a.png');

        // --- ПОСТОБРАБОТКА ---
        const renderScene = new THREE.RenderPass(scene, camera);
        const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.2, 0.4, 0.85);
        
        const composer = new THREE.EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- ОСВЕЩЕНИЕ ---
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));

        // --- МАШИНА (С КАПОТОМ a.png) ---
        const hoodGroup = new THREE.Group();
        
        // Создаем массив материалов для каждой стороны куба капота
        // 0: right, 1: left, 2: top (наша картинка), 3: bottom, 4: front, 5: back
        const hoodMaterials = [
            new THREE.MeshStandardMaterial({ color: 0x001133 }), // side
            new THREE.MeshStandardMaterial({ color: 0x001133 }), // side
            new THREE.MeshStandardMaterial({ map: hoodTexture, emissive: 0xffffff, emissiveIntensity: 0.1 }), // TOP (a.png)
            new THREE.MeshStandardMaterial({ color: 0x001133 }), // bottom
            new THREE.MeshStandardMaterial({ color: 0x001133 }), // front
            new THREE.MeshStandardMaterial({ color: 0x001133 })  // back
        ];

        const hood = new THREE.Mesh(
            new THREE.BoxGeometry(3.5, 0.1, 4),
            hoodMaterials
        );
        hoodGroup.add(hood);

        // Фары
        const lightGeo = new THREE.BoxGeometry(0.8, 0.2, 0.2);
        const lightMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const l1 = new THREE.Mesh(lightGeo, lightMat); l1.position.set(-1.2, 0.1, -2); hoodGroup.add(l1);
        const l2 = new THREE.Mesh(lightGeo, lightMat); l2.position.set(1.2, 0.1, -2); hoodGroup.add(l2);

        const createSpot = (x) => {
            const s = new THREE.SpotLight(0xffffff, 10, 50, Math.PI/6, 0.5, 1);
            s.position.set(x, 0.1, -2);
            s.target.position.set(x, -0.5, -15);
            hoodGroup.add(s); hoodGroup.add(s.target);
        };
        createSpot(-1.2); createSpot(1.2);

        hoodGroup.position.set(0, -0.8, -1.5);
        camera.add(hoodGroup);
        scene.add(camera);

        // --- ЗВЕЗДЫ ---
        const starCoords = [];
        for (let i = 0; i < 3000; i++) starCoords.push((Math.random()-0.5)*1000, Math.random()*500, (Math.random()-0.5)*1000);
        const starGeo = new THREE.BufferGeometry();
        starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starCoords, 3));
        const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.8 }));
        scene.add(stars);

        // --- ГОРОД ---
        const buildings = [];
        const gridSize = 500;
        const boxGeo = new THREE.BoxGeometry(1, 1, 1);
        
        for (let i = 0; i < 600; i++) {
            const h = Math.random() * 40 + 5;
            const w = Math.random() * 5 + 3;
            const buildingMat = new THREE.MeshStandardMaterial({
                map: bTex,
                color: 0xffffff,
                emissive: Math.random() > 0.5 ? 0x00ffff : 0xff00ff,
                emissiveIntensity: 0.3
            });

            const building = new THREE.Mesh(boxGeo, buildingMat);
            building.scale.set(w, h, w);
            building.position.set((Math.random()-0.5)*gridSize, h/2, (Math.random()-0.5)*gridSize);
            scene.add(building);
            buildings.push(building);
        }

        const grid = new THREE.GridHelper(gridSize * 2, 80, 0x00ffff, 0x330033);
        scene.add(grid);

        // --- ТРАФИК ---
        const tLights = [];
        for(let i=0; i<40; i++) {
            const l = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.2,5), new THREE.MeshBasicMaterial({color: Math.random()>0.5?0x00ffff:0xff00ff}));
            l.position.set((Math.random()-0.5)*100, 1, (Math.random()-0.5)*gridSize);
            scene.add(l); tLights.push(l);
        }

        // --- ЛОГИКА ---
        let moveFwd = false, moveBwd = false, moveL = false, moveR = false;
        let yaw = 0, pitch = 0, velocity = new THREE.Vector3();
        const ui = document.getElementById('ui'), spdElem = document.getElementById('speedometer'), music = document.getElementById('bgMusic');

        ui.addEventListener('click', () => { document.body.requestPointerLock(); music.play().catch(()=>{}); });
        document.addEventListener('pointerlockchange', () => ui.style.display = document.pointerLockElement ? 'none' : 'block');
        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement) {
                yaw -= e.movementX * 0.002; pitch -= e.movementY * 0.002;
                pitch = Math.max(-Math.PI/4, Math.min(Math.PI/4, pitch));
            }
        });

        const onKey = (v) => (e) => {
            if (e.code==='KeyW') moveFwd=v; if (e.code==='KeyS') moveBwd=v;
            if (e.code==='KeyA') moveL=v; if (e.code==='KeyD') moveR=v;
        };
        document.addEventListener('keydown', onKey(true)); document.addEventListener('keyup', onKey(false));

        function animate() {
            requestAnimationFrame(animate);
            if (document.pointerLockElement) {
                camera.rotation.set(pitch, yaw, 0, 'YXZ');
                const dir = new THREE.Vector3();
                if (moveFwd) dir.z -= 1; if (moveBwd) dir.z += 1;
                if (moveL) dir.x -= 1; if (moveR) dir.x += 1;
                dir.normalize().applyQuaternion(camera.quaternion); dir.y = 0;

                if (dir.length() > 0) velocity.addScaledVector(dir, 0.02);
                velocity.multiplyScalar(0.96);
                camera.position.add(velocity); camera.position.y = 2;

                let targetTilt = moveL ? 0.08 : (moveR ? -0.08 : 0);
                camera.rotation.z = THREE.MathUtils.lerp(camera.rotation.z, targetTilt, 0.1);
                spdElem.innerText = `SPD: ${Math.round(velocity.length()*500)} KM/H`;

                buildings.forEach(b => {
                    if (b.position.x - camera.position.x > 250) b.position.x -= 500;
                    if (b.position.x - camera.position.x < -250) b.position.x += 500;
                    if (b.position.z - camera.position.z > 250) b.position.z -= 500;
                    if (b.position.z - camera.position.z < -250) b.position.z += 500;
                });
                tLights.forEach(l => {
                    l.position.z += 2; if (l.position.z - camera.position.z > 250) l.position.z -= 500;
                });
                grid.position.set(Math.floor(camera.position.x/10)*10, 0, Math.floor(camera.position.z/10)*10);
                stars.position.copy(camera.position);
            }
            composer.render();
        }
        animate();
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
